# 汇编

## 基础

| 单位       | HEX  | DEC   | BIN              |
| ---------- | ---- | ----- | ---------------- |
| 位(bit)    | 1    | 1     | 1                |
| 字节(byte) | FF   | 255   | 11111111         |
| 字(word)   | FFFF | 65535 | 1111111111111111 |

eg:  
1000000Fh = 268,435,471d = 0001 0000 0000 0000 0000 0000 0000 1111b (32 位)

操作码占用 1 字节, 操作数占用 1~2 字节

压缩 BCD 码（Binary-Coded Decimal）, 用 4 位二进制数来表示 1 位十进制数中的 0~9 这 10 个数码，是一种二进制的数字编码形式, 用二进制编码的十进制代码

| DEC | 压缩 BCD 码 |
| --- | ----------- |
| 0   | 0000        |
| 1   | 0001        |
| 2   | 0010        |
| 3   | 0011        |
| 4   | 0100        |
| 5   | 0101        |
| 6   | 0110        |
| 7   | 0111        |
| 8   | 1000        |
| 9   | 1001        |

## DEBUG

> -   R: 查看更改 cpu 寄存器内容
>
> > ```assembly debug
> > R ax
> > FF
> > ```
> >
> > 意思等于 ax = 00FF
>
> -   D: 查看内存中内容  
>     `D <address> <length>`
>
> > address, 起始地址, 可以是段地址:偏移地址的形式(如 cs:100), 也可以是单纯的偏移地址(如 100)  
> > length, 要显示的字节数, 默认为 80 字节
> >
> > ```assembly debug
> > d ds:0 FFFF
> > ```
>
> -   E: 改写内存中内容
> -   U: 将内存中机器指令翻译成汇编指令
> -   T: 执行一条机器指令
>     > ```assembly debug
>     > R cs
>     > 1000
>     > R ip
>     > 0000
>     > T
>     > ```
>     >
>     > 使用 R 将 CS:IP 指向指令起始, 按 T 开始执行
> -   A: 以汇编格式在内存中写入一条指令
>
> > ```assembly debug
> > A 1000:0000
> > ```
> >
> > 从 1000:0000 开始写入指令, 例如:
> >
> > ```cmd
> > 1000:0000 mov ax, 1000
> > 1000:0003 mov ds, ax
> > 1000:0005 mov ax, [0]
> > 1000:0008 mov bx, [1]
> > ```

### 地址

x8086 CPU 有 20 根地址总线, 可以访问 2^20 = 1MB 的内存空间

#### 寻址

物理地址 = 段地址(Segment Address) \* 16 + 偏移地址(Effective Address)

表示方式: 段地址:偏移地址

eg:
x8086 CPU 的寻址范围:  
0000:0000 - FFFF:000F  
(即 00000 - FFFFF)  
共 1MB

FFFF:0000 = FFFF0  
FFF0:00F0 = FFFF0  
FF00:0FF0 = FFFF0  
F000:FFF0 = FFFF0

根据 `物理地址 = 段地址 * 16 + 偏移地址` 的公式, 同一个物理地址, 可以有多种表示方式

允许在`[]`中使用的寄存器只有: bx, si, di, bp
其中
bx 与 bp 不能同时使用
si 与 di 不能同时使用

[bs],[si],[di]默认以 ds 为段地址
[bp]默认以 ss 为段地址

| 寻址方式         | 举例                                                                                  |
| ---------------- | ------------------------------------------------------------------------------------- |
| 直接寻址         | `[idata]`                                                                             |
| 间接寻址         | `[bx]`                                                                                |
| 相对寻址         | `[bx+idata]`, 结构体`[bx].idata`, 数组`idata[si]`, `idata[di]`, 二维数组`[bx][idata]` |
| 基址变址寻址     | 二维数组`[bx][si]`                                                                    |
| 相对基址变址寻址 | 结构中数组`[bx].idata[si]`, 二维数组`idata[bx][si]`                                   |

### 中断

优先级

除法错误, 溢出中断, 软件中断
不可屏蔽中断
可屏蔽中断 0`
单步中断

0000:0000 - 0000:03FF 共 1024 个字节, 用于存储中断向量表

过程:

1. 获取中断类型码
2. Flags 入栈
3. TF, IF 设 0
4. CS, IP 入栈
5. 从内存地址为中断类型码*4 的 word 单元读取并设置 IP, 中断类型码*4+2 的 word 单元读取并设置 CS

#### 软件中断

#### 硬件中断

##### 内中断

硬件出错: 断电, 奇偶校验错误

运算出错: 除数为 0, 溢出, 单步中断

属于不可屏蔽中断

##### 外中断

外设请求

```assembly
mov ah, 4ch ; 调用21h号中断例程的4ch号子程序: 程序返回, 可以提供返回值
mov al, 0 ; 返回值
int 21h ; 调用21h号中断
```

##### 可屏蔽中断

###### 键盘中断(09h 号中断)

从端口 60h 中读取
扫描码: 1 byte
按下键盘, 产生扫描码(通码)
松开键盘, 产生扫描码(断码)
通码第七位: 0
断码第七位: 1
断码 = 通码 + 80H

##### 不可屏蔽中断

1. 标志寄存器入栈, IF=0, TF=0
2. CS, IP 入栈
3. (IP)=8, (CS)=0AH
